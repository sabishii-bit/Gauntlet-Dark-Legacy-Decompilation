#!/usr/bin/env python3

"""
Splits a large PDB-extracted header file into organized, manageable files.

This script parses a monolithic header file generated by pdbripper and splits it into:
- Separate files for different categories (D3D, Xbox, Windows API, Game-specific)
- Individual type definitions organized by subsystem
- A master index for easy lookup

Usage:
    python tools/split_pdb_header.py misc/Xbox/shell3D.h -o include/xbox_symbols
"""

import argparse
import re
from pathlib import Path
from typing import Dict, List, Tuple
from collections import defaultdict


class HeaderSplitter:
    def __init__(self, input_file: Path, output_dir: Path):
        self.input_file = input_file
        self.output_dir = output_dir
        self.types: Dict[str, List[str]] = defaultdict(list)
        self.type_names: Dict[str, str] = {}  # name -> category

    def categorize_type(self, type_name: str) -> str:
        """Categorize a type based on its name prefix/pattern."""
        name = type_name.lower()

        # Direct3D types
        if name.startswith(('d3d', '_d3d', 'ps_', 'vs_', 'id3dx', 'id3d')):
            return 'd3d'

        # DirectSound audio types
        if name.startswith(('ids', '_ds', 'dsound', '_dsfx_', 'hrtf')):
            return 'audio'

        # Xbox-specific types
        if name.startswith(('xgmath', 'xaudio', 'xmedia', 'xgraphics', 'xapi', 'xnet', 'xonline', 'xbox', '_xbox_', '_xinput_', '_xdevice_', '_xc_', '_xdcs_', 'ac97', 'mcpx')):
            return 'xbox'

        # Windows/NT kernel types
        if name.startswith(('_nt_', '_rtl_', '_key_', '_port_', '_cm_', '_system_', '_process', '_thread', '_file_', '_io_', '_k', '_event_', '_timer_', '_wait_', '_section_', '_mode', '_harderror_', '_shutdown_', '_sysdbg_', '_power_', '_device_power_', '_latency_')):
            return 'windows_kernel'

        # Windows security types
        if name.startswith(('_sid_', '_acl_', '_ace_', '_token_', '_security_', '_audit_')):
            return 'windows_kernel'

        # Windows GDI/User types
        if name.startswith(('gdi', 'wnd', 'msg', 'hwnd', 'hdc', 'hglrc', 'tagwnd', 'tag', '_rect')):
            return 'windows_gdi'

        # PlayStation 2 types (interesting - might indicate shared code!)
        if name.startswith(('sce', 'spu', 'gs_', 'tgs_', 'vif_', 'ipu')):
            return 'ps2'

        # Math/vector types
        if name in ('vec2', 'vec3', 'vec4', 'mat3', 'mat4', 'quat', 'matrix', 'vector', 'quaternion'):
            return 'math'
        if 'vector' in name or 'matrix' in name or 'quat' in name:
            return 'math'

        # Game-specific patterns - check against lowercase name
        # Common prefixes: sm (scene/mesh), gm (game manager), pm (player), nm (name?), cm, am, mm
        if len(name) > 2:
            for prefix in ('sm', 'gm', 'pm', 'nm', 'cm', 'am', 'mm'):
                if name.startswith(prefix):
                    # Check if followed by lowercase letter or underscore (typical game naming)
                    if name[len(prefix)] in ('_',) or name[len(prefix)].isalpha():
                        return 'game'

        # Enemy/gameplay specific types
        if 'enemy' in name or ('player' in name and 'info' in name):
            return 'game'

        # Game heap/memory management
        if 'heap' in name and 'sge' in name:
            return 'game'

        # Animation/graphics
        if 'anim' in name or 'model' in name or 'mesh' in name or 'texture' in name:
            return 'graphics'

        # Audio
        if 'sound' in name or 'audio' in name or 'music' in name:
            return 'audio'

        # String/text utilities
        if name.startswith(('_string', '_unicode_', '_guid', '_cptable')):
            return 'util'

        # Import/export tables
        if name.startswith(('import_', '_import_', '_image_')):
            return 'windows_kernel'

        # Everything else
        return 'misc'

    def extract_type_name(self, line: str) -> Tuple[str, str]:
        """Extract type name and keyword from a definition line."""
        match = re.match(r'^(struct|class|enum|union)\s+([A-Za-z_][A-Za-z0-9_:<>]*)', line)
        if match:
            return match.group(2), match.group(1)
        return None, None

    def parse_file(self):
        """Parse the input file and extract type definitions."""
        print(f"Reading {self.input_file}...")

        with open(self.input_file, 'r', encoding='utf-8', errors='ignore') as f:
            lines = f.readlines()

        print(f"Parsing {len(lines)} lines...")

        current_type = None
        current_keyword = None
        current_lines = []
        brace_depth = 0
        in_definition = False

        for i, line in enumerate(lines):
            if i % 10000 == 0:
                print(f"  Progress: {i}/{len(lines)} lines ({i*100//len(lines)}%)")

            # Skip header guards and includes
            if line.startswith('#') and not in_definition:
                continue

            # Check for type definition start
            if not in_definition:
                type_name, keyword = self.extract_type_name(line)
                if type_name:
                    current_type = type_name
                    current_keyword = keyword
                    current_lines = [line]
                    in_definition = True
                    brace_depth = 0
                    continue

            if in_definition:
                current_lines.append(line)

                # Track brace depth
                brace_depth += line.count('{') - line.count('}')

                # Check if definition is complete
                if brace_depth == 0 and (';' in line or (current_keyword == 'enum' and '}' in line)):
                    # Store the complete type definition
                    category = self.categorize_type(current_type)
                    self.types[category].append(''.join(current_lines))
                    self.type_names[current_type] = category

                    # Reset for next type
                    in_definition = False
                    current_type = None
                    current_lines = []

        print(f"\nExtracted {sum(len(v) for v in self.types.values())} type definitions")
        for category, types in sorted(self.types.items()):
            print(f"  {category}: {len(types)} types")

    def write_output_files(self):
        """Write categorized types to separate header files."""
        self.output_dir.mkdir(parents=True, exist_ok=True)

        print(f"\nWriting output files to {self.output_dir}/...")

        # Write each category to a separate file
        for category, definitions in self.types.items():
            output_file = self.output_dir / f"{category}.h"

            with open(output_file, 'w', encoding='utf-8') as f:
                guard = f"_{category.upper()}_H_"
                f.write(f"#ifndef {guard}\n")
                f.write(f"#define {guard}\n\n")
                f.write(f"// Category: {category}\n")
                f.write(f"// Extracted from Xbox PDB symbols\n")
                f.write(f"// Total types: {len(definitions)}\n")
                f.write(f"// Note: Xbox symbols - may need adaptation for GameCube\n\n")

                # Write all definitions
                for definition in definitions:
                    f.write(definition)
                    f.write("\n")

                f.write(f"\n#endif // {guard}\n")

            print(f"  Wrote {output_file} ({len(definitions)} types)")

        # Create an index file
        self.write_index()

    def write_index(self):
        """Write a master index of all types."""
        index_file = self.output_dir / "type_index.txt"

        with open(index_file, 'w', encoding='utf-8') as f:
            f.write("Type Index\n")
            f.write("=" * 80 + "\n\n")
            f.write("This index lists all types extracted from the Xbox PDB symbols.\n")
            f.write("Format: TypeName -> Category (header file)\n\n")

            for type_name in sorted(self.type_names.keys()):
                category = self.type_names[type_name]
                f.write(f"{type_name:<60} -> {category}.h\n")

        print(f"  Wrote {index_file}")

        # Create a usage guide
        self.write_usage_guide()

    def write_usage_guide(self):
        """Write a guide for using these headers with the GameCube project."""
        guide_file = self.output_dir / "README.md"

        with open(guide_file, 'w', encoding='utf-8') as f:
            f.write("# Xbox PDB Symbol Headers\n\n")
            f.write("These headers were extracted from Xbox PDB debug symbols for Gauntlet Dark Legacy.\n\n")

            f.write("## Categories\n\n")
            for category in sorted(self.types.keys()):
                count = len(self.types[category])
                f.write(f"- **{category}.h** - {count} types\n")

            f.write("\n## Usage for GameCube Decompilation\n\n")
            f.write("Since Gauntlet Dark Legacy was a multiplatform title, these Xbox symbols can help with:\n\n")
            f.write("1. **Struct Layouts**: Many game structs are likely identical or very similar across platforms\n")
            f.write("2. **Function Signatures**: Cross-reference function names and parameters\n")
            f.write("3. **Type Names**: Discover original type names for structs/classes\n")
            f.write("4. **Code Organization**: Understand subsystem boundaries (audio, graphics, gameplay)\n\n")

            f.write("### Important Notes\n\n")
            f.write("- **Platform Differences**: Xbox uses different graphics API (D3D vs GX), different memory layout, different endianness\n")
            f.write("- **Pointer Sizes**: Both Xbox and GameCube use 32-bit pointers\n")
            f.write("- **Alignment**: May differ - verify struct sizes against GameCube binary\n")
            f.write("- **Platform-Specific Code**: Filter out `d3d.h`, `xbox.h`, `windows_*.h` - these won't apply to GC\n\n")

            f.write("### Recommended Workflow\n\n")
            f.write("1. Focus on `game.h`, `math.h`, `graphics.h`, `audio.h` - these likely contain shared game logic\n")
            f.write("2. Compare struct sizes/offsets against your GameCube symbols\n")
            f.write("3. Use type names as hints, but verify layouts with actual GC data\n")
            f.write("4. Watch for interesting finds like PS2 types - indicates shared codebase!\n\n")

            f.write("### Integration with decomp-toolkit\n\n")
            f.write("You can use these headers to:\n")
            f.write("- Add known struct definitions to `include/types.h`\n")
            f.write("- Update `config/GUNE5D/symbols.txt` with discovered function/variable names\n")
            f.write("- Cross-reference with objdiff to identify matching functions\n\n")

            f.write("## Type Index\n\n")
            f.write("See `type_index.txt` for a complete alphabetical listing of all types and their categories.\n")

        print(f"  Wrote {guide_file}")


def main():
    parser = argparse.ArgumentParser(description='Split PDB-extracted header into organized files')
    parser.add_argument('input', type=Path, help='Input header file (e.g., misc/Xbox/shell3D.h)')
    parser.add_argument('-o', '--output', type=Path, default=Path('include/xbox_symbols'),
                        help='Output directory (default: include/xbox_symbols)')

    args = parser.parse_args()

    if not args.input.exists():
        print(f"Error: Input file {args.input} does not exist")
        return 1

    splitter = HeaderSplitter(args.input, args.output)
    splitter.parse_file()
    splitter.write_output_files()

    print("\nâœ“ Done! Check the output directory for categorized headers and usage guide.")
    return 0


if __name__ == '__main__':
    exit(main())
